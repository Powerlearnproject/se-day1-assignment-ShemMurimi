[![Open in Visual Studio Code](https://classroom.github.com/assets/open-in-vscode-2e0aaae1b6195c2367325f4f02e2d04e9abb55f0b24a779b69b11b9e10269abc.svg)](https://classroom.github.com/online_ide?assignment_repo_id=15816533&assignment_repo_type=AssignmentRepo)
# SE_Day1
Software Engineering Day1 Assignment

#Part 1: Introduction to Software Engineering

1. Explain what software engineering is and discuss its importance in the technology industry.

Software engineering is a systematic, disciplined, and quantifiable approach to the development, operation, and maintenance of software. It combines principles from computer science, engineering, and project management to build reliable, efficient, scalable, and maintainable software systems. Software engineering emphasizes best practices, tools, and methodologies to ensure that software meets user needs, is delivered on time, within budget, and performs well in real-world conditions.

Key Aspects of Software Engineering
Requirements Analysis: Understanding the needs of users and translating them into technical specifications.
Design: Structuring the software system's architecture, including both high-level design (overall system structure) and low-level design (detailed algorithms and data structures).
Implementation: Writing code and developing software based on the design and requirements.
Testing: Validating the software by ensuring it functions correctly, meets the requirements, and is free from defects.
Maintenance: Ongoing updates, bug fixes, and improvements to ensure the software continues to operate correctly as user needs evolve.
Project Management: Managing resources, time, and people to ensure the successful delivery of software projects.
Importance of Software Engineering in the Technology Industry
Efficiency and Productivity: With structured methodologies like Agile, Scrum, and DevOps, software engineering helps streamline the development process, improving productivity and reducing the time it takes to get products to market.

Quality and Reliability: Software engineers use practices such as code reviews, automated testing, and continuous integration to ensure software is reliable, secure, and free of critical bugs.

Scalability: Good software engineering principles help create systems that can grow and adapt as user demand increases, ensuring that the software can scale up without significant performance issues.

Cost-Effectiveness: By focusing on modular design, reusable code, and preventive maintenance, software engineering minimizes technical debt, reducing long-term costs associated with fixing poorly designed systems.

Innovation: The discipline of software engineering is vital to building new technologies like artificial intelligence, cloud computing, blockchain, and mobile applications. It empowers companies to bring innovative products and services to market.

User-Centric Design: Software engineering incorporates user feedback throughout the development process, ensuring that the final product meets the actual needs and desires of end users.

Safety and Security: In critical sectors like healthcare, finance, and transportation, software engineering ensures that systems are secure, safe, and reliable, preventing potentially catastrophic failures or breaches.

2. Identify and describe at least three key milestones in the evolution of software engineering.
   
The evolution of software engineering has been marked by several key milestones, each representing significant advancements in the way software is developed, maintained, and applied. Here are three major milestones:

1. The Emergence of Structured Programming (1960s - 1970s)
Description: In the early days of computing, software was often written in an unstructured manner, leading to complex and difficult-to-maintain codebases. The introduction of structured programming was a major shift in software development, emphasizing logical program structure and modular design.

Key Contributors: Prominent figures like Edsger W. Dijkstra advocated for structured programming as a means of improving the clarity and quality of code.
Impact: Structured programming introduced the concept of breaking programs into smaller, reusable functions or modules, making it easier to understand, debug, and maintain software. Languages like Pascal and C were designed with structured programming principles in mind, paving the way for modern programming practices.
2. The Waterfall Model and the Advent of Software Development Methodologies (1970s)
Description: The Waterfall Model, introduced by Winston W. Royce in 1970, formalized the software development process. It introduced a linear, sequential approach to software development, broken into distinct phases like requirements gathering, design, implementation, testing, deployment, and maintenance.

Key Features: The model emphasized that each phase should be completed before moving on to the next, with formal documentation at each stage.
Impact: The Waterfall Model was one of the first attempts to provide a structured process for software development, addressing the growing complexity of software systems. While it had limitations (e.g., lack of flexibility), it laid the foundation for later methodologies like Agile and iterative models.
3. The Rise of Agile and DevOps (2000s - Present)
Description: By the early 2000s, dissatisfaction with rigid, linear methodologies like Waterfall led to the emergence of Agile development methods, which emphasized flexibility, collaboration, and iterative development. The Agile Manifesto, published in 2001, promoted principles such as delivering working software frequently, adapting to changing requirements, and close collaboration between developers and customers.

Key Contributors: Prominent figures like Kent Beck, Martin Fowler, and others involved in the creation of the Agile Manifesto.
Impact: Agile transformed how software teams approached development by encouraging short development cycles (sprints), rapid feedback, and continuous improvement. It is widely adopted today and forms the basis for various frameworks like Scrum and Kanban.
DevOps, which emerged around the same time, further extended Agile principles by integrating development and operations teams. DevOps emphasizes continuous integration/continuous deployment (CI/CD), automation, and collaboration to accelerate software delivery and improve quality.

3. List and briefly explain the phases of the Software Development Life Cycle.

The Software Development Life Cycle (SDLC) is a systematic process for developing software, broken into a series of well-defined phases. Each phase has specific goals and deliverables, ensuring the final software product meets user requirements and is of high quality. Here are the main phases of the SDLC:

1. Requirement Gathering and Analysis
Description: In this phase, stakeholders (such as customers, business analysts, and developers) gather and analyze the requirements for the software. The goal is to understand what the software must do, its features, and the constraints.
Key Activities: Interviews, surveys, and workshops with stakeholders, creation of a requirements specification document, feasibility studies, and risk assessments.
2. System Design
Description: Based on the gathered requirements, the system’s architecture and design are planned. This includes both high-level design (HLD), which covers system architecture, and low-level design (LLD), which deals with detailed component design.
Key Activities: Designing the system architecture, databases, user interfaces, data flow diagrams, and creating design specifications.
3. Implementation (Coding)
Description: This is the phase where the actual coding or programming is done. Developers write the code according to the specifications laid out in the design phase.
Key Activities: Writing code in the chosen programming language, following coding guidelines, and using version control systems.
4. Testing
Description: The software is rigorously tested to ensure it is free from defects and meets the requirements. Various types of testing—such as unit testing, integration testing, system testing, and user acceptance testing (UAT)—are performed.
Key Activities: Identifying bugs, running test cases, performing automated and manual testing, and ensuring the software functions correctly under different conditions.
5. Deployment
Description: Once the software passes testing, it is deployed to the production environment where it becomes available for use by the end-users.
Key Activities: Installation and configuration of the software in the target environment, data migration (if required), and making the system live.
6. Maintenance
Description: After deployment, the software enters the maintenance phase, where it is monitored for issues, bugs are fixed, and updates are made as needed. This phase ensures the software continues to operate efficiently and meets evolving user needs.
Key Activities: Bug fixing, releasing updates and patches, and enhancing features based on user feedback.

4. Compare and contrast the Waterfall and Agile methodologies. Provide examples of scenarios where each would be appropriate.

The Waterfall and Agile methodologies are two widely used approaches for managing software development projects, but they differ significantly in how they structure the process, handle changes, and involve stakeholders.

1. Waterfall Methodology
Overview:
The Waterfall model is a linear and sequential approach to software development. It is divided into distinct phases (e.g., requirements, design, implementation, testing, and maintenance) that must be completed one after the other. The next phase begins only when the previous one is fully finished.

Key Features:

Linear and Sequential: Each phase must be completed before the next begins.
Emphasis on Documentation: Waterfall relies heavily on thorough documentation at every stage.
Rigid and Predictable: Changes in requirements are difficult to accommodate once the project is in the later stages.
Defined Deliverables: Each phase produces a set of defined deliverables, such as requirements documents, design documents, and test plans.
Advantages:

Clear structure and well-defined phases.
Easy to manage due to its straightforward nature.
Good for projects with fixed and unchanging requirements.
Progress is easily measurable as each phase has a clear end-point.
Disadvantages:

Inflexible to changes once a phase is completed.
Late testing can result in finding defects only at the end, which can be costly and time-consuming to fix.
Not ideal for projects where requirements are expected to evolve.
When to Use Waterfall:

Projects with stable and well-defined requirements.
Small or short-term projects with clear objectives.
Industries like construction or manufacturing, where processes are predictable and changes are costly.
Government contracts or mission-critical systems, where thorough documentation and review at every stage are essential.
Example:
Developing software for a medical device with strict regulatory requirements, where each phase must be rigorously documented and changes can be highly disruptive, is a good fit for Waterfall.

2. Agile Methodology
Overview:
Agile is an iterative and incremental approach to software development. It emphasizes flexibility, collaboration, and frequent delivery of smaller, working pieces of software. Agile is designed to accommodate changing requirements and involves ongoing feedback from stakeholders throughout the project.

Key Features:

Iterative and Incremental: Development occurs in small cycles (called sprints) that produce working software at the end of each iteration.
Flexibility: Requirements can change based on feedback from stakeholders, even late in the project.
Collaboration: Cross-functional teams work closely with stakeholders throughout the process.
Minimal Documentation: The focus is more on working software than on extensive documentation.
Advantages:

Highly adaptable to changing requirements.
Delivers working software quickly and continuously.
Encourages close collaboration between developers, stakeholders, and customers.
Early identification and resolution of defects.
Disadvantages:

Requires constant involvement from stakeholders.
Can be difficult to predict time, cost, and resource requirements at the outset.
Not ideal for projects requiring extensive documentation or strict regulatory compliance.
Lack of clear end goals can lead to scope creep.
When to Use Agile:

Projects with uncertain or evolving requirements.
Large or complex projects where frequent feedback is needed.
Startups or companies working on innovative products, where adaptability and speed are crucial.
Web or mobile app development, where new features and changes can be introduced frequently based on user feedback.
Example:
Developing a social media platform where user needs and features evolve rapidly based on feedback and market trends would be well-suited for Agile. Regular updates and the ability to quickly pivot based on user input are key.

Key Comparisons
Aspect	Waterfall	Agile
Approach	Linear and sequential	Iterative and incremental
Flexibility	Rigid, difficult to accommodate changes	Highly flexible, accommodates changing requirements
Customer Involvement	Involvement mainly at the beginning and end	Continuous involvement throughout development
Documentation	Emphasis on detailed documentation	Focus on working software, less documentation
Testing	happens after implementation	Testing occurs throughout the development process
Delivery	One final product at the end	Frequent delivery of working software in iterations


5. Describe the roles and responsibilities of a Software Developer, a Quality Assurance Engineer, and a Project Manager in a software engineering team.
In a software engineering team, different roles contribute to the successful development and delivery of a software project. Three key roles—Software Developer, Quality Assurance Engineer, and Project Manager—have distinct responsibilities that are essential for project success. Here’s a breakdown of each role:

1. Software Developer
Role Overview: A software developer is responsible for designing, coding, and implementing software solutions based on the project’s requirements. They work closely with other developers, designers, and stakeholders to create functional and efficient applications.
Key Responsibilities:

Coding: Write, test, and maintain the code for applications or systems using programming languages such as Java, Python, C++, JavaScript, etc.
Design: Develop software architecture and design patterns, ensuring scalability, security, and performance.
Debugging and Troubleshooting: Identify and fix bugs or issues in the code during development and post-deployment.
Collaboration: Work with other team members, such as designers, analysts, and testers, to ensure that the software meets user and business needs.
Version Control: Use version control systems like Git to manage changes in the codebase.
Documentation: Maintain code documentation to ensure future developers or maintainers understand the system.
Example Responsibilities:

Developing the back-end logic for a web application.
Collaborating with front-end developers to integrate user interfaces with server-side logic.
Writing unit tests to ensure individual components function as expected.
2. Quality Assurance (QA) Engineer
Role Overview: A QA engineer is responsible for ensuring the quality of the software by identifying and reporting bugs, testing the application thoroughly, and ensuring that it meets the project’s specifications and requirements.
Key Responsibilities:

Test Planning: Create detailed test plans, test cases, and test scripts based on requirements and specifications.
Manual and Automated Testing: Conduct various types of testing, including functional, regression, performance, and security testing, either manually or using automated tools (e.g., Selenium, JUnit).
Bug Reporting: Identify, document, and track software defects in bug-tracking tools like JIRA or Bugzilla, and collaborate with developers to resolve issues.
Continuous Testing: In Agile and DevOps environments, ensure continuous testing throughout the software development cycle, including early feedback and validation.
User Acceptance Testing (UAT): Work with users to conduct UAT, ensuring the final product meets their needs before deployment.
Collaboration: Work closely with developers to understand the system architecture and functionality and provide feedback early in the development process.
Example Responsibilities:

Testing a mobile app on different devices to ensure compatibility.
Writing automated test scripts to validate the login functionality of a web application.
Reporting issues related to poor user experience or incorrect application behavior.
3. Project Manager (PM)
Role Overview: A project manager oversees the entire software development process, ensuring that the project is completed on time, within budget, and according to the agreed-upon scope. They act as a liaison between the technical team and the business stakeholders.
Key Responsibilities:

Planning and Scheduling: Create project timelines, milestones, and schedules. Define the scope, goals, and deliverables for the project.
Resource Allocation: Assign tasks and responsibilities to team members, ensuring optimal use of resources (developers, testers, designers, etc.).
Risk Management: Identify potential risks to the project’s success (e.g., delays, budget overruns, or changing requirements) and develop strategies to mitigate those risks.
Communication: Serve as the primary point of contact between stakeholders (clients, business analysts, upper management) and the development team. Ensure clear communication of project goals, progress, and issues.
Monitoring Progress: Track the project's progress and ensure that it is on schedule. Use tools like Gantt charts, Agile boards, and project management software (e.g., Trello, Asana, JIRA).
Budget Management: Ensure the project stays within the allocated budget, making adjustments if necessary.
Problem-Solving: Address any issues or roadblocks that arise during the project and keep the team motivated and on track.
Example Responsibilities:

Coordinating a sprint planning meeting to assign tasks for the next iteration.
Managing communication between a client and the development team to clarify changing requirements.
Adjusting the project timeline after unforeseen technical challenges arise.
Summary of Roles
Role	Core Focus	Key Responsibilities
Software Developer	Writing and implementing code	Coding, debugging, designing architecture, collaboration with team, maintaining documentation
Quality Assurance Engineer	Testing software for bugs and quality	Creating test cases, running manual/automated tests, bug reporting, conducting UAT
Project Manager	Managing overall project execution	Planning, scheduling, communication with stakeholders, risk management, monitoring progress

6. Discuss the importance of Integrated Development Environments (IDEs) and Version Control Systems (VCS) in the software development process. Give examples of each.

Integrated Development Environments (IDEs) and Version Control Systems (VCS) are crucial tools in the software development process, as they significantly enhance productivity, collaboration, and code quality.

Importance of Integrated Development Environments (IDEs):
An IDE is a software suite that provides comprehensive tools to facilitate the software development process. IDEs integrate various tools that developers need, such as code editors, compilers, debuggers, and build automation tools, into a single interface, streamlining the development process.

Key Benefits of IDEs:
Code Efficiency: IDEs provide features like code completion, syntax highlighting, and error detection, which help developers write code faster and with fewer mistakes.
Debugging: IDEs typically include powerful debugging tools that allow developers to trace code execution, set breakpoints, and inspect variables, making it easier to find and fix errors.
Project Management: IDEs help in managing large projects by organizing files and providing easy navigation through complex codebases.
Integrated Tools: With built-in support for version control systems, testing frameworks, and deployment pipelines, IDEs create a seamless development workflow.
Cross-Platform Development: Many IDEs allow for cross-platform development, enabling the same code to be written and tested on multiple platforms (e.g., web, mobile, desktop).
Examples of IDEs:
Visual Studio Code: A popular, lightweight IDE with extensive plugin support for multiple languages and frameworks.
IntelliJ IDEA: A powerful IDE primarily used for Java development but supports other languages with its extensive plugin ecosystem.
Eclipse: An open-source IDE widely used for Java and other programming languages, featuring an extensive library of plugins.
PyCharm: A dedicated IDE for Python development that offers powerful debugging and code navigation features.
Importance of Version Control Systems (VCS):
A VCS is a tool that helps developers manage changes to source code over time. It tracks modifications to files, facilitates collaboration among developers, and maintains a history of all versions, allowing developers to revert to previous states when needed.

Key Benefits of VCS:
Collaboration: VCS enables multiple developers to work on the same project concurrently by managing changes made by different team members and merging them into a single codebase.
History Tracking: VCS keeps a detailed record of every change made to the code, making it easy to track when and why changes were made. This is particularly helpful when debugging or auditing code.
Branching and Merging: VCS supports the creation of branches, allowing developers to work on new features or bug fixes independently before merging them back into the main codebase. This ensures the stability of the main project while new features are developed.
Backup and Restore: Since VCS keeps all versions of the code, it serves as a backup mechanism, allowing developers to revert to previous versions if necessary.
Accountability: With VCS, every change is associated with a specific developer, making it easier to identify who made what changes and when, fostering a sense of accountability within the team.
Examples of VCS:
Git: The most widely used distributed VCS, popular for its branching and merging capabilities. Git is often paired with platforms like GitHub, GitLab, or Bitbucket for cloud-based repository hosting.
Subversion (SVN): A centralized VCS that is easier to set up for teams but less flexible than Git in terms of branching and offline work.

7.What are some common challenges faced by software engineers? Provide strategies to overcome these challenges.


8.Explain the different types of testing (unit, integration, system, and acceptance) and their importance in software quality assurance.
Software engineers face a variety of challenges throughout their careers, ranging from technical difficulties to project management and interpersonal issues. Successfully navigating these challenges requires a combination of technical skills, problem-solving abilities, and soft skills.

1. Managing Complex Codebases
As projects grow, the size and complexity of the codebase increase, making it difficult to maintain, debug, and add new features without introducing errors. Complex dependencies and poorly structured code can lead to technical debt, slowing down future development.

Strategies to Overcome:

Modular Design: Break down code into smaller, reusable components or modules. This makes the code easier to manage and allows for independent updates and testing.
Code Refactoring: Regularly refactor code to improve structure, readability, and maintainability without changing its functionality. Refactoring helps reduce technical debt over time.
Automated Testing: Implement unit tests, integration tests, and continuous integration (CI) pipelines to catch issues early and ensure changes do not break existing functionality.
2. Keeping Up with Technological Advancements
Technology is constantly evolving, with new frameworks, languages, and tools emerging at a rapid pace. Keeping up with these advancements is crucial for software engineers to stay relevant and competitive.

Strategies to Overcome:

Continuous Learning: Dedicate time to learning through online courses, tutorials, and conferences. Platforms like Coursera, Udemy, and Pluralsight offer up-to-date courses on the latest technologies.
Hands-on Practice: Work on side projects or contribute to open-source projects to gain practical experience with new tools and frameworks.
Peer Learning: Participate in developer communities, attend meetups, and engage in code reviews with colleagues to learn from others and share knowledge.
3. Debugging and Problem-Solving
Debugging is a common challenge for software engineers, especially when dealing with cryptic error messages, elusive bugs, or unexpected behavior in production systems. Debugging can be time-consuming and frustrating, often leading to delays.

Strategies to Overcome:

Systematic Approach: Use a step-by-step approach to isolate the source of the issue. Break the problem down and eliminate possible causes one by one.
Logging and Monitoring: Implement detailed logging and real-time monitoring in applications to capture useful information when issues arise. This helps in diagnosing the root cause faster.
Rubber Duck Debugging: Explain the problem to a colleague or even to an inanimate object (like a rubber duck). This often helps engineers identify overlooked issues in their thought process.
4. Time Management and Deadlines
Software engineers often juggle multiple tasks, including coding, attending meetings, fixing bugs, and learning new technologies. Balancing these tasks while meeting deadlines can lead to stress and burnout.

Strategies to Overcome:

Prioritization: Use task management frameworks like Kanban or Agile to prioritize tasks based on importance and urgency. Focus on high-impact tasks first.
Time Blocking: Allocate specific time slots for coding, meetings, and other responsibilities. This ensures uninterrupted focus on key tasks.
Clear Communication: Set realistic deadlines and communicate clearly with stakeholders about progress and potential roadblocks. Early communication can prevent last-minute stress.
5. Collaborating with Non-Technical Stakeholders
Engineers often need to collaborate with stakeholders who may not have a technical background. Explaining complex technical concepts in a way that is understandable and actionable can be a challenge.

Strategies to Overcome:

Simplify Communication: Use analogies or simple terms when explaining technical concepts to non-technical stakeholders. Focus on the impact and benefits rather than the technical details.
Active Listening: Understand the needs and concerns of stakeholders. This helps engineers translate business requirements into technical solutions that align with overall project goals.
Documentation: Maintain clear and concise documentation of technical decisions, code changes, and project progress. This ensures transparency and alignment with stakeholders.
6. Handling Legacy Code
Working with legacy codebases—older systems built with outdated technologies—can be particularly challenging due to missing documentation, lack of modern standards, or brittle code.

Strategies to Overcome:

Incremental Updates: Gradually refactor or modernize legacy code rather than attempting a complete rewrite, which can be risky and time-consuming.
Comprehensive Testing: Write tests for legacy code to ensure that changes do not introduce new issues.
Document as You Go: Add comments and documentation as you work through legacy code to make it easier for future developers to understand.

#Part 2: Introduction to AI and Prompt Engineering


1. Define prompt engineering and discuss its importance in interacting with AI models.
Prompt engineering is the practice of crafting and optimizing input prompts to elicit the most accurate, relevant, or desired responses from AI models, particularly large language models (LLMs) like GPT. The prompt can consist of questions, instructions, or other forms of input that guide the AI model to generate outputs aligned with the user's needs. As AI models do not inherently understand context in the way humans do, prompt engineering plays a crucial role in making interactions with AI more productive and reliable.

Importance of Prompt Engineering:
Maximizing Output Quality: AI models are capable of generating a vast range of responses. However, the quality of the output often depends on how well the prompt is formulated. A well-constructed prompt can minimize ambiguity and ensure the model produces the most relevant and useful information. For instance, a vague prompt may result in a broad or inaccurate answer, whereas a specific, clear prompt will yield more precise results.

Example:

Poor prompt: "Explain technology."
Good prompt: "Explain the importance of cloud computing in modern enterprise IT infrastructures."
Contextual Accuracy: Models like GPT do not inherently have memory of previous interactions or context outside of a specific session. Prompt engineering can provide necessary context directly within the input. This is particularly important for ensuring that the model’s responses are accurate and aligned with user expectations, especially in complex or domain-specific tasks.

Example:

Without context: "How does it work?"
With context: "How does blockchain technology ensure data security in decentralized systems?"
Efficiency in Communication: Well-designed prompts can reduce the need for multiple rounds of clarification or follow-up questions, which improves the efficiency of interactions. In scenarios like customer service chatbots, educational tools, or automated writing assistants, prompt engineering ensures the AI can deliver helpful responses without additional input.

Bias Mitigation: AI models can inadvertently produce biased or inappropriate content based on the training data they’ve been exposed to. Prompt engineering allows users to minimize bias by crafting prompts that are specific, balanced, and designed to guide the AI toward producing neutral, unbiased outputs.

Example:

Instead of asking, "Why are electric cars better than gasoline cars?" a more neutral prompt might be, "Compare the advantages and disadvantages of electric cars and gasoline cars."
Customizing AI Behavior: Through prompt engineering, users can tailor the tone, style, or form of the AI's responses to suit specific needs. For example, one might ask the AI to write an explanation in a professional tone, a casual tone, or even for a specific audience (e.g., experts vs. beginners).

Example:

"Explain quantum computing to a 12-year-old" versus "Explain quantum computing to an advanced computer science student."
Handling Multi-step or Complex Tasks: For tasks that require multiple steps or that are complex, prompt engineering helps by breaking down the request into manageable parts and guiding the AI through a structured process. For example, in code generation or multi-step problem solving, prompts can be crafted to ensure each stage of the task is handled effectively.

Example:

"Write a Python function to sort a list of numbers in ascending order, and explain each step."

2. Provide an example of a vague prompt and then improve it by making it clear, specific, and concise. Explain why the improved prompt is more effective.
Vague Prompt Example:
"Tell me about technology."

This prompt is broad and lacks direction, making it unclear what specific information the user is seeking. The AI might respond with general information about technology, which could cover a wide range of topics like the history of technology, its impact on society, or current technological trends. The output is likely to be too generic and not tailored to the user's specific needs.

Improved Prompt:
"Explain the impact of artificial intelligence on the healthcare industry, focusing on diagnostics and patient care."

Why the Improved Prompt is More Effective:
Clarity: The revised prompt specifies a particular area of technology—artificial intelligence—rather than leaving it open-ended. This gives the AI clear instructions on which technological domain to address.

Specificity: By focusing on AI's impact within a defined industry (healthcare), and even narrowing it further to diagnostics and patient care, the prompt limits the scope of the response. This ensures the AI provides information relevant to a specific field rather than offering a broad, less informative answer.

Conciseness: The prompt is still concise but includes key terms that define the boundaries of the response. It strikes a balance between detail and brevity, which helps the AI understand the user’s needs without overwhelming it with too much detail.
